#!/usr/bin/env bash

#configure.sh: Should install and configure all needed openstack packages.

NETWORK_CONFIG ="/etc/network/interfaces"
GCC_EXEC=`which gcc`
NOV_URL="${:nova-url}"
NOVA_CONFIG="/etc/nova/nova.conf"
BASE_DIR=$HOME
EZ_SETUP="http://peak.telecommunity.com/dist/ez_setup.py"
EASY_INSTALL=`which easy_install`
PYTHON=`which python`
NOVA_USER=$USER

IPv4=`ip addr show eth0 | grep 'inet ' | awk '{print $2}' | cut -d/ -f1`
if [ -z "$IPv4" ];
  then IPv4="127.0.0.1"
fi
echo " " 
echo " " 
echo " " 
echo "#########################################################################################"
echo "#########                                                                     ###########"
echo "#########  AUTO CONFIGURE AND INSTALL SCRIPT FOR OPENSTACK NOVA-COMPUTE NODE  ###########"
echo "#########                                                                     ###########"
echo "#########             ******Network ip adress: $IPv4                          ###########"
echo "#########                                                                     ###########"
echo "#########################################################################################"
echo " " 
echo " " 
echo " " 
ip link set eth0 promisc on

cat >$NETWORK_CONFIG <<EOF
# The loopback network interface
auto lo
iface lo inet loopback

# The primary network interface
auto eth0
                    
# Bridge network interface for VM networks 
auto br100 
iface br100 inet static 
address 192.168.100.1 
netmask 255.255.255.0 
bridge_stp off
bridge_fd 0
EOF

BRCTL_EXEC=`which brctl`
if [ -z "$BRCTL_EXEC" -o ! -x "$BRCTL_EXEC" ]; then
  apt-get install -y bridge-utils ;
  BRCTL_EXEC=`which brctl`
fi

$BRCTL_EXEC addbr br100

#Restart the network to take  new network configuration.
/etc/init.d/networking restart

if [ -z "$GCC_EXEC" -o ! -x "$GCC_EXEC" ]; then
  apt-get install -y gcc g++ ;
fi

apt-get install -y python-dev
apt-get install -y gnutls-bin gnutls-dev
apt-get install -y libdevmapper-dev libdevmapper
apt-get install -y python-all-dev
apt-get install -y kvm libvirt-bin
apt-get install -y python-libvirt
apt-get install -y libxml2-dev libxslt-dev
apt-get install -y python-lxml

GIT_EXEC=`which git`
if [ -z "$GIT_EXEC" -o ! -x "$GIT_EXEC" ]; then
  apt-get install -y git ;
  GIT_EXEC=`which git`
fi
GIT_EXEC=`which git`

#Remove all pip tmp cache is to prevent installation failure
rm -rf /tmp/pip_build_root/*
#Install python packages*/

if [ -z "$EASY_INSTALL" -o ! -x "$EASY_INSTALL" ]; then
  cd $BASE_DIR; wget $EZ_SETUP -O ez_setup.py ;
  $PYTHON $BASE_DIR/ez_setup.py ;
  EASY_INSTALL=`which easy_install` ;
fi

$GIT_EXEC clone $NOV_URL $BASE_DIR/nova;
chown -R $NOVA_USER: $BASE_DIR/nova
$EASY_INSTALL pip
$EASY_INSTALL pbr
cd $BASE_DIR/nova; $PYTHON setup.py install

#Create Nova Working directory
mkdir -p /opt/stack
mkdir -p /opt/stack/data
mkdir -p /opt/stack/data/nova
mkdir -p /opt/stack/data/nova/instances
mkdir -p /opt/stack/log

NOVA_COMPUTE_EXEX=`which nova-compute`
if [ -z "$NOVA_COMPUTE_EXEX" -o ! -x "$NOVA_COMPUTE_EXEX" ]; then
  echo "ERROR: can't find nova-compute executable file!!!!"
  exit 1
fi

cp -rf $BASE_DIR/nova/etc/nova /etc/

cat >$NOVA_CONFIG <<EOF
[DEFAULT]
firewall_driver = nova.virt.libvirt.firewall.IptablesFirewallDriver
compute_driver = libvirt.LibvirtDriver
flat_interface = eth0
flat_network_bridge = br100
vlan_interface = eth0
public_interface = br100
network_manager = nova.network.manager.FlatDHCPManager
host = ${:nova-host}
glance_api_servers = ${:slap-ipv4}:9292
rabbit_password = ${:nova-passwd}
rabbit_host = ${:slap-ipv4}
rpc_backend = nova.openstack.common.rpc.impl_kombu
ec2_dmz_host = ${:slap-ipv4}
vncserver_proxyclient_address = $IPv4
vncserver_listen = $IPv4
vnc_enabled = true
xvpvncproxy_base_url = http://$IPv4:6081/console
novncproxy_base_url = ${:vnc-url}/vnc_auto.html
logging_exception_prefix = %(color)s%(asctime)s.%(msecs)03d TRACE %(name)s ESC[01;35m%(instance)sESC[00m
logging_debug_format_suffix = ESC[00;33mfrom (pid=%(process)d) %(funcName)s %(pathname)s:%(lineno)dESC[00m
logging_default_format_string = %(asctime)s.%(msecs)03d %(color)s%(levelname)s %(name)s [ESC[00;36m-%(color)s] ESC[01;35m%(instance)s%(color)s%(message)sESC[00m
logging_context_format_string = %(asctime)s.%(msecs)03d %(color)s%(levelname)s %(name)s [ESC[01;36m%(request_id)s ESC[00;36m%(user_name)s %(project_name)s%(color)s] ESC[01;35m%(instance)s%(color)s%(message)sESC[00m
instances_path = /opt/stack/data/nova/instances
lock_path = /opt/stack/data/nova
state_path = /opt/stack/data/nova
log_dir = /opt/stack/log
volume_api_class = nova.volume.cinder.API
enabled_apis = ec2,osapi_compute,metadata
instance_name_template = instance-%08x
libvirt_cpu_mode = none
libvirt_type = qemu
sql_connection = mysql://root:${:nova-passwd}@${:slap-ipv4}/nova?charset=utf8
my_ip = $IPv4
osapi_compute_extension = nova.api.openstack.compute.contrib.standard_extensions
s3_port = 3333
s3_host = ${:slap-ipv4}
ec2_host = ${:slap-ipv4}
rabbit_host = ${:slap-ipv4}
osapi_compute_listen = ${:slap-ipv4}
keystone_ec2_url = http://${:slap-ipv4}:5000/v2.0/ec2tokens
default_floating_pool = public
iscsi_ip_prefix = 192.168.100
fixed_range = 
force_dhcp_release = True
dhcpbridge_flagfile = /etc/nova/nova.conf
scheduler_driver = nova.scheduler.filter_scheduler.FilterScheduler
rootwrap_config = /etc/nova/rootwrap.conf
api_paste_config = /etc/nova/api-paste.ini
allow_resize_to_same_host = True
auth_strategy = keystone
debug = True
verbose = True

[osapi_v3]
enabled = True

[spice]
enabled = false
html5proxy_base_url = http://$IPv4:6082/spice_auto.html
EOF

#Add Nova-compute in init.d If file not exist now
cat > /etc/init.d/nova-compute << EOF
#! /bin/sh
### BEGIN INIT INFO
# Provides:          skeleton
# Required-Start:    \$remote_fs \$syslog
# Required-Stop:     \$remote_fs \$syslog
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: Example initscript
# Description:       This file should be used to construct scripts to be
#                    placed in /etc/init.d.
### END INIT INFO

PATH=/sbin:/usr/sbin:/bin:/usr/bin
DESC="OpenStack Conpute Node"
NAME=nova-compute
DAEMON=$NOVA_COMPUTE_EXEX
DAEMON_ARGS="--config-file $NOVA_CONFIG"
PIDFILE=/var/run/\$NAME.pid
SCRIPTNAME=/etc/init.d/\$NAME

# Exit if the package is not installed
[ -x "\$DAEMON" ] || exit 0

# Load the VERBOSE setting and other rcS variables
. /lib/init/vars.sh

# Define LSB log_* functions.
# Depend on lsb-base (>= 3.2-14) to ensure that this file is present
# and status_of_proc is working.
. /lib/lsb/init-functions

#
# Function that starts the daemon/service
#
do_start()
{
  # Return
	#   0 if daemon has been started
	#   1 if daemon was already running
	#   2 if daemon could not be started
	start-stop-daemon --start --quiet --background -m --oknodo --pidfile \$PIDFILE --exec \$DAEMON --test > /dev/null \\
		|| return 1
	start-stop-daemon --start --quiet --background -m --oknodo --pidfile \$PIDFILE --exec \$DAEMON -- \\
		\$DAEMON_ARGS \\
		|| return 2
}

#
# Function that stops the daemon/service
#
do_stop()
{
	# Return
	#   0 if daemon has been stopped
	#   1 if daemon was already stopped
	#   2 if daemon could not be stopped
	#   other if a failure occurred
	start-stop-daemon --stop --quiet --retry=TERM/30/KILL/5 --pidfile \$PIDFILE --name \$NAME
	RETVAL="\$?"
	[ "\$RETVAL" = 2 ] && return 2
	# Wait for children to finish too if this is a daemon that forks
	# and if the daemon is only ever run from this initscript.
	# If the above conditions are not satisfied then add some other code
	# that waits for the process to drop all resources that could be
	# needed by services started subsequently.  A last resort is to
	# sleep for some time.
	start-stop-daemon --stop --quiet --oknodo --retry=0/30/KILL/5 --exec \$DAEMON
	[ "\$?" = 2 ] && return 2
	# Many daemons don't delete their pidfiles when they exit.
	rm -f \$PIDFILE
	return "\$RETVAL"
}

#
# Function that sends a SIGHUP to the daemon/service
#
do_reload() {
	#
	# If the daemon can reload its configuration without
	# restarting (for example, when it is sent a SIGHUP),
	# then implement that here.
	#
	start-stop-daemon --stop --signal 1 --quiet --pidfile \$PIDFILE --name \$NAME
	return 0
}

case "\$1" in
  start)
	[ "\$VERBOSE" != no ] && log_daemon_msg "Starting \$DESC" "\$NAME"
	do_start
	case "\$?" in
		0|1) [ "\$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "\$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  stop)
	[ "\$VERBOSE" != no ] && log_daemon_msg "Stopping \$DESC" "\$NAME"
	do_stop
	case "\$?" in
		0|1) [ "\$VERBOSE" != no ] && log_end_msg 0 ;;
		2) [ "\$VERBOSE" != no ] && log_end_msg 1 ;;
	esac
	;;
  status)
       status_of_proc "\$DAEMON" "\$NAME" && exit 0 || exit \$?
       ;;
  #reload|force-reload)
	#
	# If do_reload() is not implemented then leave this commented out
	# and leave 'force-reload' as an alias for 'restart'.
	#
	#log_daemon_msg "Reloading \$DESC" "\$NAME"
	#do_reload
	#log_end_msg \$?
	#;;
  restart|force-reload)
	#
	# If the "reload" option is implemented then remove the
	# 'force-reload' alias
	#
	log_daemon_msg "Restarting \$DESC" "\$NAME"
	do_stop
	case "\$?" in
	  0|1)
		do_start
		case "\$?" in
			0) log_end_msg 0 ;;
			1) log_end_msg 1 ;; # Old process is still running
			*) log_end_msg 1 ;; # Failed to start
		esac
		;;
	  *)
	  	# Failed to stop
		log_end_msg 1
		;;
	esac
	;;
  *)
	echo "Usage: \$SCRIPTNAME {start|stop|status|restart|force-reload}" >&2
	exit 3
	;;
esac

:
EOF

chmod +x /etc/init.d/nova-compute

update-rc.d nova-compute defaults
/etc/init.d/nova-compute restart > /dev/null 2>&1

exit 0
